
# backend/orchestrator.py
###################### Tazrian's Update Oct 12, 2025 #####################################

from typing import List, Dict, Any, Optional, Tuple
from dataclasses import dataclass
import logging
import time
import os
import json
import hashlib
from concurrent.futures import ThreadPoolExecutor
from datetime import timedelta

from redis import Redis

from backend.extraction.llm_extractor import LLMExtractor, ExtractedParameters
from backend.geocoding.geocoder import Geocoder, Coordinates, Isochrone, SearchZone
from backend.waypoints.waypoint_searcher import WaypointSearcher, Waypoint
from backend.routing.route_builder import RouteBuilder, Route, RouteSegment
from backend.scoring.route_scorer import RouteScorer, RouteScore


# -------------------- Small Redis JSON cache --------------------
class Cache:
    def __init__(self, url: str | None = None):
        self.client = Redis.from_url(url or os.getenv("REDIS_URL", "redis://localhost:6379/0"))

    @staticmethod
    def _hash_key(namespace: str, payload: Dict[str, Any]) -> str:
        s = json.dumps(payload, sort_keys=True, separators=(",", ":"))
        h = hashlib.sha256(s.encode("utf-8")).hexdigest()
        return f"{namespace}:{h}"

    def get_json(self, namespace: str, payload: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        key = self._hash_key(namespace, payload)
        val = self.client.get(key)
        return json.loads(val) if val else None

    def set_json(self, namespace: str, payload: Dict[str, Any], value: Dict[str, Any], ttl_seconds: int = 600) -> None:
        key = self._hash_key(namespace, payload)
        self.client.setex(key, timedelta(seconds=ttl_seconds), json.dumps(value))


@dataclass
class RouteRequest:
    user_prompt: str
    max_results: int = 5
    origin: Optional[Dict[str, Any]] = None   # {"text":..., "lat":..., "lon":...}
    destination: Optional[Dict[str, Any]] = None
    time: Optional[Dict[str, Any]] = None     # {"max_duration_min":..., "departure_time_utc":...}


class RouteOrchestrator:
    """Main orchestrator for the route generation pipeline."""
    
    def __init__(self, config: Dict[str, str]):
        self.config = config
        
        # Initialize modules
        self.extractor = LLMExtractor(config.get("llm_api_key", ""))
        # Mapbox tokens used by both Geocoder and RouteBuilder
        mapbox_key = config.get("geocoding_api_key", "") or config.get("routing_api_key", "")
        self.geocoder = Geocoder(mapbox_key)
        self.waypoint_searcher = WaypointSearcher(config.get("poi_api_key", ""))  # Overpass; key unused
        self.route_builder = RouteBuilder(mapbox_key)
        self.route_scorer = RouteScorer(
            clip_model_name=config.get("clip_model_name", "openai/clip-vit-base-patch32"),
            mapillary_token=config.get("mapillary_token", "") or None
        )
        
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)

        self.cache = Cache(config.get("redis_url"))
        self.pool = ThreadPoolExecutor(max_workers=int(os.getenv("ORCH_MAX_WORKERS", "8")))

    # -------------------- (De)serialization helpers --------------------
    def _coords_to_dict(self, c: Coordinates) -> Dict[str, float]:
        return {"latitude": c.latitude, "longitude": c.longitude}

    def _coords_from_dict(self, d: Dict[str, float]) -> Coordinates:
        return Coordinates(latitude=float(d["latitude"]), longitude=float(d["longitude"]))

    def _iso_to_dict(self, iso: Isochrone) -> Dict[str, Any]:
        return {
            "center": self._coords_to_dict(iso.center),
            "travel_time_minutes": int(iso.travel_time_minutes),
            "polygon": [self._coords_to_dict(p) for p in iso.polygon],
        }

    def _iso_from_dict(self, d: Dict[str, Any]) -> Isochrone:
        return Isochrone(
            center=self._coords_from_dict(d["center"]),
            travel_time_minutes=int(d["travel_time_minutes"]),
            polygon=[self._coords_from_dict(p) for p in d.get("polygon", [])],
        )

    def _zone_to_dict(self, z: SearchZone) -> Dict[str, Any]:
        return {
            "origin_isochrone": self._iso_to_dict(z.origin_isochrone),
            "destination_isochrone": self._iso_to_dict(z.destination_isochrone),
            "intersection_polygon": [self._coords_to_dict(p) for p in z.intersection_polygon],
        }

    def _zone_from_dict(self, d: Dict[str, Any]) -> SearchZone:
        return SearchZone(
            origin_isochrone=self._iso_from_dict(d["origin_isochrone"]),
            destination_isochrone=self._iso_from_dict(d["destination_isochrone"]),
            intersection_polygon=[self._coords_from_dict(p) for p in d.get("intersection_polygon", [])],
        )

    def _wp_to_dict(self, w: Waypoint) -> Dict[str, Any]:
        return {
            "name": w.name,
            "coordinates": self._coords_to_dict(w.coordinates),
            "category": w.category,
            "relevance_score": float(w.relevance_score),
            "metadata": w.metadata,
            "input_query": w.input_query,
        }

    def _wp_from_dict(self, d: Dict[str, Any]) -> Waypoint:
        return Waypoint(
            name=d["name"],
            coordinates=self._coords_from_dict(d["coordinates"]),
            category=d["category"],
            relevance_score=float(d["relevance_score"]),
            metadata=d.get("metadata", {}),
            input_query=d.get("input_query", ""),
        )

    def _seg_to_dict(self, s: RouteSegment) -> Dict[str, Any]:
        return {
            "start": self._coords_to_dict(s.start),
            "end": self._coords_to_dict(s.end),
            "distance_meters": float(s.distance_meters),
            "duration_seconds": int(s.duration_seconds),
            "instructions": s.instructions,
            "polyline": s.polyline,
        }

    def _seg_from_dict(self, d: Dict[str, Any]) -> RouteSegment:
        return RouteSegment(
            start=self._coords_from_dict(d["start"]),
            end=self._coords_from_dict(d["end"]),
            distance_meters=float(d["distance_meters"]),
            duration_seconds=int(d["duration_seconds"]),
            instructions=list(d.get("instructions", [])),
            polyline=d.get("polyline", ""),
        )

    def _route_to_dict(self, r: Route) -> Dict[str, Any]:
        return {
            "origin": self._coords_to_dict(r.origin),
            "destination": self._coords_to_dict(r.destination),
            "waypoints": [self._wp_to_dict(w) for w in r.waypoints],
            "segments": [self._seg_to_dict(s) for s in r.segments],
            "total_distance_meters": float(r.total_distance_meters),
            "total_duration_seconds": int(r.total_duration_seconds),
            "constraints_applied": r.constraints_applied,
            "input_queries": list(getattr(r, "input_queries", [])),
        }

    def _route_from_dict(self, d: Dict[str, Any]) -> Route:
        return Route(
            origin=self._coords_from_dict(d["origin"]),
            destination=self._coords_from_dict(d["destination"]),
            waypoints=[self._wp_from_dict(w) for w in d.get("waypoints", [])],
            segments=[self._seg_from_dict(s) for s in d.get("segments", [])],
            total_distance_meters=float(d["total_distance_meters"]),
            total_duration_seconds=int(d["total_duration_seconds"]),
            constraints_applied=d.get("constraints_applied", {}),
            input_queries=list(d.get("input_queries", [])),
        )

    def _wp_key(self, w: Waypoint) -> str:
        return f"{w.name}:{round(w.coordinates.latitude,6)}:{round(w.coordinates.longitude,6)}"

    # -------------------- Main entrypoint --------------------
    def generate_routes(self, request: RouteRequest) -> Dict[str, Any]:
        """
        Generate routes based on user prompt.
        Returns a dict directly consumable by the API layer.
        """
        t0 = time.time()
        timings: Dict[str, float] = {}

        try:
            # -------- 1) LLM Extraction (cache) --------
            self.logger.info("Extracting parameters from user prompt")
            t = time.time()
            llm_key = {"prompt": request.user_prompt}
            cached_llm = self.cache.get_json("llm_extract_v1", llm_key)

            if cached_llm:
                ep = ExtractedParameters(**cached_llm)
            else:
                ep = self.extractor.extract_parameters(request.user_prompt)
                # Persist as dict (ExtractedParameters is a dataclass)
                self.cache.set_json("llm_extract_v1", llm_key, {
                    "origin": ep.origin,
                    "destination": ep.destination,
                    "time_flexibility_minutes": ep.time_flexibility_minutes,
                    "waypoint_queries": ep.waypoint_queries,
                    "constraints": ep.constraints,
                }, ttl_seconds=1800)
            timings["llm_extract"] = time.time() - t

            # -------- 2) Apply UI overrides (do not mutate ep types) --------
            max_additional_minutes = ep.time_flexibility_minutes or 30
            if request.time and isinstance(request.time.get("max_duration_min"), int):
                max_additional_minutes = request.time["max_duration_min"]

            origin_text = request.origin["text"] if (request.origin and request.origin.get("text")) else ep.origin
            dest_text   = request.destination["text"] if (request.destination and request.destination.get("text")) else ep.destination

            # -------- 3) Geocode origin/destination in parallel (cache) --------
            self.logger.info("Geocoding origin and destination")
            t = time.time()

            def _cached_geocode(text: str) -> Coordinates:
                gkey = {"text": (text or "").strip().lower()}
                cached = self.cache.get_json("geocode_v1", gkey)
                if cached:
                    return self._coords_from_dict(cached)
                coords = self.geocoder.geocode_address(text)
                self.cache.set_json("geocode_v1", gkey, self._coords_to_dict(coords), ttl_seconds=86400)
                return coords

            # If UI supplied lat/lon, use them; else geocode
            if request.origin and request.origin.get("lat") is not None and request.origin.get("lon") is not None:
                origin_coords = Coordinates(latitude=float(request.origin["lat"]), longitude=float(request.origin["lon"]))
            else:
                f1 = self.pool.submit(_cached_geocode, origin_text)

            if request.destination and request.destination.get("lat") is not None and request.destination.get("lon") is not None:
                dest_coords = Coordinates(latitude=float(request.destination["lat"]), longitude=float(request.destination["lon"]))
            else:
                f2 = self.pool.submit(_cached_geocode, dest_text)

            if "origin_coords" not in locals():  # if not set by UI
                origin_coords = f1.result()
            if "dest_coords" not in locals():    # if not set by UI
                dest_coords = f2.result()
            timings["geocode"] = time.time() - t

            # -------- 4) Build search zone (cache) --------
            self.logger.info("Creating search zone")
            t = time.time()
            zone_key = {
                "o": self._coords_to_dict(origin_coords),
                "d": self._coords_to_dict(dest_coords),
                "max_additional": int(max_additional_minutes),
                "mode": ep.constraints.get("transport_mode", "walking"),
            }
            cached_zone = self.cache.get_json("search_zone_v1", zone_key)
            if cached_zone:
                search_zone = self._zone_from_dict(cached_zone)
            else:
                search_zone = self.geocoder.create_search_zone(
                    origin=origin_coords,
                    destination=dest_coords,
                    max_additional_time=int(max_additional_minutes),
                    transport_mode=ep.constraints.get("transport_mode", "walking"),
                )
                self.cache.set_json("search_zone_v1", zone_key, self._zone_to_dict(search_zone), ttl_seconds=1800)
            timings["search_zone"] = time.time() - t

            # -------- 5) Waypoint search (cache) --------
            self.logger.info("Searching for waypoints via Overpass")
            t = time.time()
            waypoint_queries = ep.waypoint_queries or []
            wp_key = {
                "zone": zone_key,  # stable hash via nested dicts
                "queries": waypoint_queries,
            }
            cached_wps = self.cache.get_json("waypoints_v1", wp_key)
            if cached_wps:
                waypoints = [self._wp_from_dict(w) for w in cached_wps]
            else:
                waypoints = self.waypoint_searcher.search_waypoints(search_zone, waypoint_queries)
                self.cache.set_json("waypoints_v1", wp_key, [self._wp_to_dict(w) for w in waypoints], ttl_seconds=1800)
            timings["waypoints"] = time.time() - t

            # -------- 6) Build candidate routes (cache) --------
            self.logger.info("Building candidate routes with Mapbox Directions")
            t = time.time()
            constraints = ep.constraints or {}
            r_key = {
                "o": self._coords_to_dict(origin_coords),
                "d": self._coords_to_dict(dest_coords),
                "wps": [self._wp_key(w) for w in waypoints[:20]],  # cap to stabilize cache key
                "constraints": constraints,
            }
            cached_routes = self.cache.get_json("routes_v1", r_key)
            if cached_routes:
                routes = [self._route_from_dict(r) for r in cached_routes]
            else:
                routes = self.route_builder.build_routes(origin_coords, dest_coords, waypoints, constraints)
                self.cache.set_json("routes_v1", r_key, [self._route_to_dict(r) for r in routes], ttl_seconds=900)
            timings["routes_build"] = time.time() - t

            # -------- 7) Score & rank (batch) --------
            self.logger.info("Scoring routes (CLIP + efficiency + relevance)")
            t = time.time()
            scored: List[RouteScore] = self.route_scorer.score_routes(routes, request.user_prompt)
            scored.sort(key=lambda s: s.overall_score, reverse=True)
            top = scored[: max(1, int(request.max_results or 5))]
            timings["score_rank"] = time.time() - t

            # -------- 8) API formatting --------
            def _route_to_api(o: RouteScore) -> Dict[str, Any]:
                r = o.route
                return {
                    "score": round(float(o.overall_score), 3),
                    "scores": {
                        "clip": round(float(o.clip_score), 3),
                        "efficiency": round(float(o.efficiency_score), 3),
                        "preference": round(float(o.preference_match_score), 3),
                        "images_used": int(o.num_images),
                    },
                    "distance_m": float(r.total_distance_meters),
                    "duration_s": int(r.total_duration_seconds),
                    "origin": self._coords_to_dict(r.origin),
                    "destination": self._coords_to_dict(r.destination),
                    "waypoints": [
                        {
                            "name": w.name,
                            "category": w.category,
                            "relevance_score": float(w.relevance_score),
                            "input_query": w.input_query,
                            "coordinates": self._coords_to_dict(w.coordinates),
                        }
                        for w in r.waypoints
                    ],
                    "segments": [
                        {
                            "distance_m": float(s.distance_meters),
                            "duration_s": int(s.duration_seconds),
                            "instructions": s.instructions,
                            "polyline": s.polyline,
                            "start": self._coords_to_dict(s.start),
                            "end": self._coords_to_dict(s.end),
                        }
                        for s in r.segments
                    ],
                }

            api_routes = [_route_to_api(x) for x in top]

            total_time = time.time() - t0
            timings["total"] = total_time

            return {
                "routes": api_routes,
                "processing_time_seconds": total_time,
                "metadata": {
                    "total_routes_generated": len(routes),
                    "waypoints_found": len(waypoints),
                    "timings": timings,
                },
            }

        except Exception as e:
            self.logger.exception("Error generating routes: %s", e)
            # Bubble up â€“ API layer will 500
            raise

    def health_check(self) -> Dict[str, Any]:
        return {
            "extractor": "healthy",
            "geocoder": "healthy",
            "waypoint_searcher": "healthy",
            "route_builder": "healthy",
            "route_scorer": "healthy",
        }
